; Generated by Calypsi ISO C compiler for 6502

    .rtmodel version,"1"
    .rtmodel codeModel,"plain"
    .rtmodel core,"45gs02"
    .rtmodel target,"mega65"
    .extern _AllocStackSave
    .extern _RestoreRegisters
    .extern _Vfp
    .extern _Vsp
    .extern _Zp
    .extern printf


;; Kernal jump table
    SETLFS: .equ 0xffba
    SETNAM: .equ 0xffbd
    LKUPLA: .equ 0xff5f
    LOAD:   .equ 0xffd5
    SETBNK: .equ 0xff6b
    LFN:    .equ 0x01

;; Special Registers
   BANK_SWITCH:  .equ  0xd030

;; BP Layout
    BP_HIGH:    .equ  0x16      ;; High byte for the BP
    BP_PTR:     .equ  0x1600

    STR_LO:     .equ  0x00
    STR_HI:     .equ  0x01
    NUM1_LO:    .equ  0x00
    NUM1_HI:    .equ  0x01
    NUM2_LO:    .equ  0x02
    NUM2_HI:    .equ  0x03
    RES_LO:     .equ  0x04
    RES_HI:     .equ  0x05
    SAV_D030:   .equ  0x06


;  #include "../m65script_fileio.h"
;
;
;  int m65script_load(char* buffer, int size ,       char* filename,   uint8_t device ){
;;                    _Zp + _Zp+1   _Zp+2 + _Zp+3    _Zp+4 + _Zp+5,    _Zp+6
;;
            .section code,text
            .public m65script_load
            .extern _Zp

;; returns 0 or error code on error.
;; Possible error codes include
;; 4 (file was not found),
;; 5 (device was not present),
;; 8 (no name was specified for a serial load),
;; 9 (an illegal device number was specified).
m65script_load:
        ;; TODO: Find a way to check the buffer size!
        ;;pha         ;; save <size
        ;;phx         ;; save >size
        clc

        lda BANK_SWITCH
        sta BP_PTR + SAV_D030 ;; Absolute call due to BP == 0

        ;; always use ZP for kernel calls
        lda #0x00
        tab

        ;; Activate C65 ROM $C000 - $CFFF
        lda #0x64       ;; 0110 0100
        sta BANK_SWITCH

        ;; TODO: LKUPLA and LKUPSA routines can be used to find unused logical file numbers and secondary addresses.

        ;; SETLFS
        lda #LFN        ;; Logical File Number
        ldx zp:_Zp+6   ;; Set device number (saved above)
        ldy #0x00       ;; Secondary Address: no command, relocating
        jsr SETLFS


        ;; SETNAM
        ldx zp:_Zp+4   ;; <Name
        ldy zp:_Zp+5   ;; >Name
        jsr count_string
        jsr SETNAM

        ;; SETBNK for load
        lda #0x00       ;; Bank for code
        tax             ;; Bank for filename
        jsr SETBNK

        ;; LOAD FILE
        clc
        lda #0x00       ;;SET FLAG FOR A LOAD
        ldx zp:_Zp      ;; <Buffer Adress
        ldy zp:_Zp+1    ;; >Buffer Address

        ;; save buffer for counting later
        jsr enable_bp
        stx zp:NUM2_LO
        sty zp:NUM2_HI
        jsr disable_bp

        jsr LOAD        ;; CLOSE not necessary! XY = ending address

        ;; LOAD returns error code in A when carry flag set,
        ;; otherwise X and Y contains end address

        pha             ;; save error code for later

        ;; Disable C65 ROM
        lda BP_PTR + SAV_D030   ;; Restore previously stored $d030
        sta BANK_SWITCH

        pla             ;; pull error code from stack

        bcs error_out$

        ;; count bytes read
        jsr enable_bp
        stx zp:NUM1_LO
        sty zp:NUM1_HI
        jsr subtract_16
        jsr disable_bp
        lda BP_PTR + RES_LO
        sta zp:_Zp
        lda BP_PTR + RES_HI
        sta zp:_Zp+1
        rts
    error_out$:
        sta zp:_Zp      ;; set low byte to error code
        ldx #0x00       ;; set high byte to zero
        stx zp:_Zp+1
        rts             ;; Returns the error code in A

    enable_bp:
        pha
        lda #BP_HIGH
        tab       ;; BP to $1600
        pla
        rts

    disable_bp:
        pha
        lda #0x00
        tab
        pla
        rts

;; counts number of bytes of a zero
;; terminated string (max. 255 bytes!)
;; ldy: > string_addr
;; ldx: < string_addr
;; returns A : count
count_string:
        jsr enable_bp
        stx zp:STR_LO           ;; save < addr
        sty zp:STR_HI           ;; save > addr
        ldy #0x00
    loop$:
        lda (zp:STR_LO), y
        cmp #0x00               ;; check whether string ended
        beq exit$
        iny                     ;; try next char
        bne loop$               ;; max reached?
        dey                     ;; max length = $FF
    exit$:
        phy                     ;; push count
        ldx zp:STR_LO           ;; restore < string_addr
        ldy zp:STR_HI           ;; restore > string_addr
        jsr disable_bp
        pla                     ;; pull count to A
        clc
        rts


; subtracts number 2 from number 1 and writes result out
; res = num1 - num2
subtract_16:
        cld
        lda zp:NUM1_LO
        sec             ;; set carry for borrow purpose
        sbc zp:NUM2_LO     ;; perform subtraction on the LSBs
        sta zp:RES_LO
        lda zp:NUM1_HI     ;; do the same for the MSBs, with carry
        sbc zp:NUM2_HI     ;; set according to the previous result
        sta zp:RES_HI
        rts

; For testing.
break:
        lda #0x64        ;; 0110 0100
        sta BANK_SWITCH
        brk
